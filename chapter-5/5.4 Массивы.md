# Массивы

- Это упорядоченная коллекция данных

## Отличия обькетов от массивов,

- обькет не предоставляет методов управления порядком элементов. Мы не можем вставить новое свойство «между» уже существующими

Последний элемент массива

```js
let fruits = ["Apple", "Orange", "Plum"];

console.log(fruits[-1]); // undefined
console.log(fruits.at(-1)); // "Plum"
```

## Вариант применения массивов

- `очередь` – один из самых распространённых вариантов применения массива. исп принцип FIFO «первый пришёл — первый вышел». применяются только 2 типа операций `push` добавляет элемент в конец, `shift` удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первымю.

- `стек` LIFO - cтруктура данных. Массивы нужны для организации `стек` представляющий собой список элементов, организованных по принципу LIFO «последний пришёл — первый вышел». применяются только 2 типа операций к `стек` - `push` добавление эл-ов в конец, `pop` удаление эл-ов с конца.

- `for..of` - предоставляет доступ к значению элемента массива.

- `for..in` в 10-100 раз медленнее, неиспользовать для перебора массива.

```js
let appleArr = new Array(10000).fill("Apple");

const obj = {};
for (let i = 0; i < 10000; i++) {
  obj[`prop${i}`] = "Apple";
}

console.log("obj: ", obj);
console.log("appleArr: ", appleArr);
```

## toString

- не имеют ни Symbol.toPrimitive, ни функционирующего valueOf, они реализуют только преобразование toString

```js
let arr = [1, 2, 3];

console.log(arr); // 1,2,3
console.log(String(arr) === "1,2,3"); // true
console.log([] + 1); // "1"
console.log([1] + 1); // "11"
console.log([1, 2] + 1); // "1,21"
```

## медленный for in для массивов?

Обычно for...of будет медленнее для массивов из-за дополнительных проверок на итерируемость.

```js
let orangeArr = new Array(10).fill("Orange");

const personPrototype = {
  greet: function () {
    console.log(`Hello, my name is ${this.name}`);
  },
};

orangeArr["john"] = personPrototype;

function getTimeForOfArray() {
  const start = performance.now().toFixed(2);

  for (let prop of orangeArr) {
    console.log("prop: ", prop);
    let variable = prop;
  }

  const end = performance.now().toFixed(2);
  console.log(`for of time: ${end - start} milliseconds`);
  // Run Code 5.863899998366833
  // Chrome (10) 0.7999999970197678
  // Chrome (1000) 0.10000000149011612
  // Chrome (100_000) 3.7999999970197678
}

function getTimeForInArray() {
  const start = performance.now().toFixed(2);

  for (let key in orangeArr) {
    console.log("key: ", key);
    let variable = key;
  }

  const end = performance.now().toFixed(2);
  console.log(`for in time: ${end - start} milliseconds`);
  // Run Code 0.7041999995708466
  // Chrome (10) 0.5999999940395355
  // Chrome (1000) 0.10000000149011612
  // Chrome (100_000) 10.800000004470348
}

getTimeForOfArray();
getTimeForInArray();

// Обычно for...of будет медленнее для массивов из-за дополнительных проверок на итерируемость?
```

# Методы массивов

| **Наименование** | **Синтаксис** | **Возврат** | **Особенности** |
| --- | --- | --- | --- |
| **push** | `arr.push(element1, ..., elementN)` | Новая длина массива | Добавляет элементы в конец массива. Изменяет исходный массив. |
| **pop** | `arr.pop()` | Удаленный элемент | Удаляет последний элемент массива. Изменяет исходный массив. |
| **shift** | `arr.shift()` | Удаленный элемент | Удаляет первый элемент массива. Изменяет исходный массив. |
| **unshift** | `arr.unshift(element1, ..., elementN)` | Новая длина массива | Добавляет элементы в начало массива. Изменяет исходный массив. |
| **concat** | `arr.concat(array2, ..., arrayN)` | Новый массив | Объединяет массивы или элементы в один массив. Не изменяет исходный массив. |
| **slice** | `arr.slice(start, end)` | Новый массив | Возвращает копию части массива между `start` и `end` (не включая `end`). |
| **splice** | `arr.splice(start, deleteCount, ...items)` | Удаленные элементы | Удаляет, заменяет или добавляет элементы в массив. Изменяет исходный массив. |
| **forEach** | `arr.forEach(callback)` | `undefined` | Выполняет функцию для каждого элемента массива. Не возвращает нового массива. |
| **map** | `arr.map(callback)` | Новый массив | Создает новый массив, вызывая функцию для каждого элемента. |
| **filter** | `arr.filter(callback)` | Новый массив | Создает массив, содержащий элементы, которые прошли проверку функции. |
| **reduce** | `arr.reduce(callback, initialValue)` | Одно значение | Применяет функцию к каждому элементу массива, сводя его к одному значению. |
| **reduceRight** | `arr.reduceRight(callback, initialValue)` | Одно значение | Аналогичен `reduce`, но идет справа налево. |
| **find** | `arr.find(callback)` | Найденный элемент или `undefined` | Возвращает первый элемент, удовлетворяющий условию в функции. |
| **findIndex** | `arr.findIndex(callback)` | Индекс или `-1` | Возвращает индекс первого элемента, удовлетворяющего условию. |
| **indexOf** | `arr.indexOf(element, fromIndex)` | Индекс или `-1` | Возвращает индекс первого вхождения элемента. |
| **lastIndexOf** | `arr.lastIndexOf(element, fromIndex)` | Индекс или `-1` | Возвращает индекс последнего вхождения элемента. |
| **includes** | `arr.includes(element, fromIndex)` | `true` или `false` | Проверяет, содержит ли массив определенный элемент. |
| **some** | `arr.some(callback)` | `true` или `false` | Возвращает `true`, если хотя бы один элемент удовлетворяет условию. |
| **every** | `arr.every(callback)` | `true` или `false` | Возвращает `true`, если все элементы удовлетворяют условию. |
| **sort** | `arr.sort([compareFunction])` | Исходный массив | Сортирует элементы массива. Изменяет исходный массив. |
| **reverse** | `arr.reverse()` | Исходный массив | Переворачивает порядок элементов массива. Изменяет исходный массив. |
| **join** | `arr.join([separator])` | Строка | Объединяет элементы массива в строку, используя указанный разделитель. |
| **flat** | `arr.flat([depth])` | Новый массив | Разворачивает вложенные массивы до указанной глубины. |
| **flatMap** | `arr.flatMap(callback)` | Новый массив | Комбинирует `map` и `flat` (глубина разворачивания — 1). |
| **fill** | `arr.fill(value, start, end)` | Исходный массив | Заполняет массив указанным значением от `start` до `end`. Изменяет исходный массив. |
| **copyWithin** | `arr.copyWithin(target, start, end)` | Исходный массив | Копирует последовательность элементов внутри массива. Изменяет исходный массив. |
| **toString** | `arr.toString()` | Строка | Возвращает строку, представляющую массив. |
| **toLocaleString** | `arr.toLocaleString()` | Строка | Возвращает строку, используя локальные настройки. |

# Задачи
