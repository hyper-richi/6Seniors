# Числа

```js
let billion = 1000000000;

let billion = 1_000_000_000;

console.log(str.test);
```

## "e"

```js
let billion = 1e9; // 1 миллиард, буквально: 1 и 9 нулей

let ms = 1e-6; // шесть нулей слева от 1 = 0.000001
```

## Шестнадцатеричные, двоичные и восьмеричные числа

Шестнадцатеричные числа широко используются в JavaScript для представления цветов, кодировки символов и многого другого. Естественно, есть короткий стиль записи: 0x, после которого указывается число.

-   0x шестнадцатеричные
-   0b двоичных
-   0o для восьмеричных

```js
console.log(0xff); // 255
let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255
```

## toString(base)

1. base=16 — для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры могут быть 0..9 или A..F.

2. base=2 — обычно используется для отладки побитовых операций, цифры 0 или 1.

3. base=36 — максимальное основание, цифры могут быть 0..9 или A..Z.

```js
// Две точки eсли нам надо вызвать метод непосредственно на числе
(123456).toString(36);
(123456).toString(36); // то же смаое
```

## Округление

-   `Math.floor` - (floor: пол/минимальный уровень), округление в меньшую сторону. 3.1 -> 3

-   `Math.ceil` - (сушд: потолок) округление в большую сторону. 3.1 -> 4

-   `Math.round` - округ до ближайшего целого. 3.1 -> 3, 3.6 -> 4, а -1.1 -> -1

-   `Math.trunc` - отрезает дробную часть. 3.1 -> 3

    -эти методы окргуляют до целого числа обрабатывая только десятичный знак.

| Значение | Math.floor | Math.ceil | Math.round | Math.trunc |
| -------- | ---------- | --------- | ---------- | ---------- |
| 3.1      | 3          | 4         | 3          | 3          |
| 3.6      | 3          | 4         | 4          | 3          |
| -1.1     | -2         | -1        | -1         | -1         |
| -1.6     | -2         | -1        | -2         | -1         |

1. `toFixed(n)` округляет число до `n` знаков после запятой и возвращает строковое представление результата
2. Умножить и разделить. (num \* 100) / 100

## Неточные вычисления

Причина та же – потеря точности. Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, остальные 11 бит хранят позицию десятичной точки и один бит – знак. Так что если 52 бит не хватает на цифры, то при записи пропадут младшие разряды.

Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт бесконечность

Дроби, такие как 0.1, 0.2, являются бесконечной дробью в двоичной форме.

`0.1 + 0.2 // 0.30000000000000004`

Решение: округлить результат используя метод `toFixed(n)`:

## Проверка: `isFinite` и `isNaN`

`isNaN(value)` - преобразует значение в число и проверяет является ли оно NaN

`isFinite(value)` преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity

`Number.isNaN` и `Number.isFinite` – это более «строгие» версии функций `isNaN` и `isFinite`. Они не преобразуют аргумент в число, а наоборот – первым делом проверяют, является ли аргумент числом (принадлежит ли он к типу `number`).

-   `Number.isNaN(value)` возвращает `true` только в том случае, если аргумент принадлежит к типу `number` и является `NaN`

-   `Number.isFinite(value)` возвращает `true` только в том случае, если аргумент принадлежит к типу `number` и не является `NaN/Infinity/-Infinity`. Во всех остальных случаях возвращает `false`.

-   `Object.is`

    1. Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
    2. Значения 0 и -0 разные: Object.is(0, -0) === false, это редко используется, но технически эти значения разные.

-   `parseInt` и `parseFloat` Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. Функция `parseInt` возвращает целое число, а `parseFloat` возвращает число с плавающей точкой

// то же смаое

# Задачи

https://www.codewars.com/kata/57ea0ee4491a151fc5000acf

1.  Задача Знаете ли вы, сколько времени требуется для зарядки аккумулятора вашего мобильного телефона от 0% до 100%? Это зависит от емкости аккумулятора вашего мобильного телефона и мощности зарядного устройства. Грубый метод расчета:

0% --> 85% (fast charge) (battery capacity(mAh) \* 85%) / power of the charger(mA)

85% --> 95% (decreasing charge) (battery capacity(mAh) \* 10%) / (power of the charger(mA) \_ 50%)

95% --> 100% (trickle charge) (battery capacity(mAh) \* 5%) / (power of the charger(mA) \_ 20%)

Например: емкость вашего аккумулятора составляет 1000 мАч, и вы используете зарядное устройство на 500 мАч, для зарядки аккумулятора вашего мобильного телефона от 0% до 100% потребуется время:

0% --> 85% (fast charge) 1.7 (hour)

85% --> 95% (decreasing charge) 0.4 (hour)

95% --> 100% (trickle charge) 0.5 (hour)

total times = 1.7 + 0.4 + 0.5 = 2.6 (hour) Полная функция calculateTime, которая принимает два аргумента battery и charger, возвращает, сколько часов может заряжать аккумулятор от 0% до 100%. Результатом должно быть число, округленное до 2 знаков после запятой (в Haskell округлять не нужно).

```js
function calculateTime(battary, charge) {
    let fastCharge = (battary * 0.85) / charge;
    let decreasingCharge = (battary * 0.1) / (charge * 0.5);
    let trickleCharge = (battary * 0.05) / (charge * 0.2);
    return fastCharge + decreasingCharge + trickleCharge;
}

calculateTime(1000, 500); // 2.6
calculateTime(1500, 500); //
calculateTime(2000, 1000); //
calculateTime(5000, 1000); //
```

2. https://www.codewars.com/kata/56a628758f8d06b59800000f/javascript

Число является самоописательным, когда n-я цифра описывает количество n, встречающееся в числе.

Пример:

Для числа 21200:

В числе два нуля, поэтому первая цифра — 2. В числе одна единица, поэтому вторая цифра — 1. В числе две двойки, поэтому третья цифра — 2. В числе нет цифры 3, поэтому четвертая цифра — 0. В числе нет цифры 4, поэтому пятая цифра — 0.

Числа могут быть любой длины до 9 цифр и только полные целые числа. Для заданного числа выведите функцию, которая возвращает:

True если число является самоописательным иначе False.

```js
function selfDescriptive(num) {
    const numStr = num.toString();
    const length = numStr.length;

    const dataCounts = Array(length).fill(0);
    for (let char of numStr) {
        dataCounts[char]++;
    }

    for (let i = 0; i < length; i++) {
        if (numStr[i] != dataCounts[i]) {
            console.log(false);
            return false;
        }
    }
    console.log(true);
    return true;
}

// let selfDescriptive = n => [...n+=''].every((v, i) => (n.match(RegExp(i, 'g')) || []).length == v);

selfDescriptive(21200); // true
selfDescriptive(3211000); // true
selfDescriptive(42101000); // true
selfDescriptive(1210); // true
selfDescriptive(2020); // true

selfDescriptive(21230); // false
selfDescriptive(11200); // false
selfDescriptive(99252); // false
selfDescriptive(24781); // false
```

3. Рассмотрим таблицу, состоящую из n строк и n столбцов. Ячейка, расположенная на пересечении i-й строки и j-го столбца, содержит число i×j. Строки и столбцы нумеруются, начиная с 1. Вам дано положительное целое число x. Ваша задача — подсчитать количество ячеек в таблице, содержащих число x. Пример Для n = 5 и x = 5 результат должен быть равен 2.

```
1  2  3  4  (5)
2  4  6  8  10
3  6  9  12 15
4  8  12 16 20
(5) 10 15 20 25

```

```js
function countNumber(n, x) {
    //coding and coding..
    let count = 0;
    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= n; j++) {
            if (i * j === x) count++;
        }
    }
    // console.log("count", count);
}

countNumber(5, 5); // 2
countNumber(10, 5); // 2
countNumber(6, 12); // 4
countNumber(9, 484); // 0
```
