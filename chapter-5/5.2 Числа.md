# Числа

```js
let billion = 1000000000;

let billion = 1_000_000_000;

console.log(str.test);
```

## "e"

```js
let billion = 1e9; // 1 миллиард, буквально: 1 и 9 нулей

let ms = 1e-6; // шесть нулей слева от 1 = 0.000001
```

## Шестнадцатеричные, двоичные и восьмеричные числа

Шестнадцатеричные числа широко используются в JavaScript для представления цветов, кодировки символов и многого другого. Естественно, есть короткий стиль записи: 0x, после которого указывается число.

-   0x шестнадцатеричные
-   0b двоичных
-   0o для восьмеричных

```js
console.log(0xff); // 255
let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255
```

## toString(base)

1. base=16 — для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры могут быть 0..9 или A..F.

2. base=2 — обычно используется для отладки побитовых операций, цифры 0 или 1.

3. base=36 — максимальное основание, цифры могут быть 0..9 или A..Z.

```js
// Две точки eсли нам надо вызвать метод непосредственно на числе
(123456).toString(36);
(123456).toString(36); // то же смаое
```

## Округление

-   `Math.floor` - округление в меньшую сторону. 3.1 -> 3

-   `Math.ceil` - округление в большую сторону. 3.1 -> 4

-   `Math.round` - округ до ближайшего целого. 3.1 -> 3, 3.6 -> 4, а -1.1 -> -1

-   `Math.trunc` - отрезает дробную часть. 3.1 -> 3

| Значение | Math.floor | Math.ceil | Math.round | Math.trunc |
| -------- | ---------- | --------- | ---------- | ---------- |
| 3.1      | 3          | 4         | 3          | 3          |
| 3.6      | 3          | 4         | 4          | 3          |
| -1.1     | -2         | -1        | -1         | -1         |
| -1.6     | -2         | -1        | -2         | -1         |

1. `toFixed(n)` округляет число до `n` знаков после запятой и возвращает строковое представление результата
2. Умножить и разделить. (num \* 100) / 100

## Неточные вычисления

Причина та же – потеря точности. Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, остальные 11 бит хранят позицию десятичной точки и один бит – знак. Так что если 52 бит не хватает на цифры, то при записи пропадут младшие разряды.

## Проверка: `isFinite` и `isNaN`

`isNaN(value)` - преобразует значение в число и проверяет является ли оно NaN

`isFinite(value)` преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity

`Number.isNaN` и `Number.isFinite` – это более «строгие» версии функций `isNaN` и `isFinite`. Они не преобразуют аргумент в число, а наоборот – первым делом проверяют, является ли аргумент числом (принадлежит ли он к типу `number`).

-   `Number.isNaN(value)` возвращает `true` только в том случае, если аргумент принадлежит к типу `number` и является `NaN`

-   `Number.isFinite(value)` возвращает `true` только в том случае, если аргумент принадлежит к типу `number` и не является `NaN/Infinity/-Infinity`. Во всех остальных случаях возвращает `false`.

-   `Object.is`

    1. Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
    2. Значения 0 и -0 разные: Object.is(0, -0) === false, это редко используется, но технически эти значения разные.

-   `parseInt` и `parseFloat` Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. Функция `parseInt` возвращает целое число, а `parseFloat` возвращает число с плавающей точкой

// то же смаое

# Задачи Не все, Добавить!!!


-   Написать реализацию parseInt

```js
function parseIntCustom(str) {
    let resultStr = "";

    for (let i = 0; i < str.length; i++) {
        if (!Object.is(NaN, Number(str[i]))) {
            resultStr += str[i];
        } else break;
    }
    return Number(resultStr);
}

console.log(parseIntCustom("100456px"));
console.log(parseInt("100123px"));
```
