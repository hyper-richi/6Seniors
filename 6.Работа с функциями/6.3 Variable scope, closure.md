# Variable scope, closure

- при создании внутренней функции создается замыкание

  - Собственные переменные.
  - Переменные и аргументы внешней функции.
  - Глобальные переменные.

```js
function greetCustomer() {
  const customerName = "Daniels";
  function greetingMsg() {
    console.log("Hi! " + customerName); // Hi! Daniels
  }
  //greetingMsg();
  console.dir(greetingMsg); // Closure (greetCustomer) {customerName: 'Daniels'}
}
```

- замыкание на аргументы **name, age**

```js
function createPerson(name, age) {
  return {
    getName: function () {
      return name;
    },
    getAge: function () {
      return age;
    },
    setAge: function (num) {
      age = num;
    },
  };
}

const user = createPerson("Jack", 155);
console.dir(user);
console.log("user.getAge: ", user.getAge());
user.setAge(300);
console.log("user.getAge: ", user.getAge());

const user2 = createPerson("Bob", 106);
console.dir(user2);
console.log("user2.getAge: ", user2.getAge());
user2.setAge(16);
console.log("user2.getAge: ", user2.getAge());
```

## Задачи

1. **Замыкание и счётчик** <br> Создайте функцию `createCounter`, которая возвращает функцию-счётчик. Каждый вызов счётчика должен увеличивать значение на 1. Используйте замыкание для хранения текущего значения счётчика.

```javascript
function createCounter() {
  let count = 0;

  return function () {
    count++;
    console.log(count); // Что выведет?
  };
}

const counter = createCounter();
counter(); // 1
counter(); // 2
```

2. **Замыкание и приватные данные** <br> Создайте функцию `createPerson`, которая принимает имя и возраст и возвращает объект с методами:

`getName` — возвращает имя.

`getAge` — возвращает возраст.

`setAge` — изменяет возраст.

Используйте замыкание, чтобы сделать данные приватными.

```javascript
function createPerson(name, age) {
  return {
    getName: function () {
      return name;
    },
    getAge: function () {
      return age;
    },
    setAge: function (num) {
      age = num;
    },
  };
}
```

3. **Замыкание и таймер** <br> Напишите функцию `createTimer`, которая принимает время в секундах и возвращает функцию. Возвращаемая функция должна каждую секунду выводить оставшееся время в консоль, а по истечении времени вывести "Time's up!". Используйте замыкание для хранения оставшегося времени.

```javascript
function createTimer(timeInSec) {
  let timer = timeInSec;

  return function () {
    let timerId = setInterval(() => {
      console.log(timer);
      --timer;
      if (timer === 0) {
        // если не отменить setInterval, timer продолжит уменьшаться
        clearInterval(timerId);
        console.log("Time's up!");
      }
    }, 1000);
  };
}

const timerStart = createTimer(10);
timerStart();
```

4. **Замыкание и мемоизация** <br/> Создайте функцию `memoize`, которая принимает другую функцию и возвращает её мемоизированную версию. Мемоизация — это техника оптимизации, при которой результаты вызовов функции сохраняются, чтобы избежать повторных вычислений. Используйте замыкание для хранения кэша результатов.

```js
function memoize(cb) {
  let memoCb = cb;
  return function () {
    return memoCb;
  };
}
```

5. **Генератор паролей** <br> Напишите функцию `createPasswordGenerator(length)`, которая принимает длину пароля и возвращает другую функцию. Эта функция при каждом вызове должна генерировать новый случайный пароль из букв и цифр заданной длины.

```javascript
function createPasswordGenerator(length) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  const numbers = "0123456789";

  function randomChar() {
    return chars[Math.floor(Math.random() * chars.length)];
  }
  function randomCount() {
    return numbers[Math.floor(Math.random() * numbers.length)];
  }
  return function () {
    let i = 0;
    let pass = "";
    while (i < length) {
      if (i % 2 === 0) {
        pass += randomChar();
        i++;
      } else {
        pass += randomCount();
        i++;
      }
    }
    return pass;
  };
}

const password10 = createPasswordGenerator(10);
const password7 = createPasswordGenerator(7);
console.log("password10: ", password10());
console.log("password7: ", password7());
```

6. **Лимит вызовов** <br> Создайте функцию `createLimitedFunction(fn, limit)`, которая принимает другую функцию `fn` и максимальное количество вызовов `limit`. Возвращенная функция должна вызывать `fn`, но только `limit` раз, после чего всегда возвращать `undefined`.

```javascript
function createLimitedFunction(fn, limit = 1) {
  let count = limit;
  return function () {
    if (count === 1) count--;
    while (count >= 1) {
      fn();
      if (count === 1) break;
      count--;
    }

    if (count === 0) {
      return undefined;
    }
  };
}

function fn() {
  console.log("fn");
}

const limit3 = createLimitedFunction(fn, 3);
limit3(); // fn,fn,fn
console.log(limit3()); // undefined
console.log(limit3()); // undefined
const limit4 = createLimitedFunction(fn, 4);
console.log(limit3()); // undefined
limit4(); // fn,fn,fn,fn
console.log(limit4()); // undefined
```

7. `**Сложное закрытие** <br/> Как бы вы исправили этот пример, чтобы регистрировать значения 0, 1, 2после прохождения 1 секунды? Напишите свое решение в комментарии ниже!`

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(function log() {
    console.log(i); // What is logged?
  }, 1000);
}
```

8. `**Правильное или неправильное сообщение** <br/> Как бы вы исправили log()функцию, чтобы вернуть сообщение с фактическим count значением? Напишите свое решение в комментарии ниже!`

```js
function createIncrement() {
  let count = 0;
  function increment() {
    count++;
  }

  let message = `Count is ${count}`;
  function log() {
    console.log(message);
  }

  return [increment, log];
}

const [increment, log] = createIncrement();
increment();
increment();
increment();
log(); // What is logged?
```

9. `**Восстановить инкапсуляцию** <br/> Измените реализацию стека выше, используя концепцию замыкания, так, чтобы не было возможности получить доступ к items массиву за пределами createStack()области действия функции: stack.items; // => undefined`

```js
function createStack() {
  return {
    items: [],
    push(item) {
      this.items.push(item);
    },
    pop() {
      return this.items.pop();
    },
  };
}

const stack = createStack();
stack.push(10);
stack.push(5);
stack.pop(); // => 5

stack.items; // => [10]
stack.items = [10, 100, 1000]; // Encapsulation broken!
```

10. `**Умное умножение** <br/> Напишите функцию multiply(), которая умножает 2 числа: Если multiply(num1, numb2)функция вызывается с 2 аргументами, она должна вернуть произведение 2 аргументов.Но если вызвать с 1 аргументом const anotherFunc = multiply(num1), функция должна вернуть другую функцию. Возвращаемая функция при вызове anotherFunc(num2)выполняет умножение num1 * num2.`

```js
multiply(4, 5); // => 20
multiply(3, 3); // => 9
const double = multiply(2);
double(5); // => 10
double(11); // => 22
```

```js
function multiply(num1, num2) {
  // Write your code here...
}
```
