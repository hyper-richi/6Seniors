# `setTimeout` и `setInterval`

## `setTimeout`

- **Назначение**: Позволяет выполнить функцию один раз через указанный интервал времени.
- **Синтаксис**:

  ```js

  let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);

  ```

- `func|code`: Функция или строка кода для выполнения.

- `delay`: Задержка в миллисекундах (по умолчанию 0).

- `arg1, arg2, ...`: Аргументы, передаваемые в функцию.

Отмена выполнения:

- `clearTimeout(timerId)`

## `setInterval`

- **Назначение**: Позволяет выполнять функцию повторно через указанный интервал времени.
- **Синтаксис**:

  ```js

  let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);

  ```

- `func|code`: Функция или строка кода для выполнения.

- `delay`: Задержка в миллисекундах (по умолчанию 0).

- `arg1, arg2, ...`: Аргументы, передаваемые в функцию.

Отмена выполнения:

- `clearInterval(timerId);`

### setTimeout с нулевой задержкой

`setTimeout(func, 0)` или `setTimeout(func)` планирует вызов `func` как можно скорее после завершения текущего кода.

### Особенности

- Минимальная задержка - 4 мс даже если указано 0.

- setTimeout/Interval не гарантирует точное время – задержка может увеличиваться из-за нагрузки.

- setInterval не ждет выполнения предыдущего вызова, поэтому возможны наложения вызовов.


Рекурсивный setTimeout: Используется для более точного контроля интервалов, особенно если выполнение функции занимает время.

```js
let timerId = setTimeout(function tick() {
  // код
  timerId = setTimeout(tick, 200);
}, 200);
```

Очередь задач: Если таймеры поставлены в очередь, они выполняются в порядке очереди, но с учётом задержек.
