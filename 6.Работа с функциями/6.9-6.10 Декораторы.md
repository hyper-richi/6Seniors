# Декораторы и методам `call`, `apply`, `bind`

## Декораторы

Декоратор — это функция, которая принимает другую функцию и добавляет функциональность, не меняя исходный код.

### Пример декоратора

```js
function slow(x) {
  // Ресурсоёмкая задача
  console.log(`Called with ${x}`);
  return x;
}

function cachingDecorator(func) {
  let cache = new Map();

  return function (x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func(x); // Вызываем оригинальную функцию
    cache.set(x, result);
    return result;
  };
}

slow = cachingDecorator(slow); // Применяем декоратор
console.log(slow(1)); // Кешируем результат
console.log(slow(1)); // Результат берётся из кеша
```

## bind()

- создает новую функцию, и когда эта новая функция вызывается, он устанавливает объект в `this` из первого аргумента, все последующие аргументы передадутся в аргументы новой функции.
- привязывает объект к методу из первого аргумента.
- фиксирует аргументы для новой функции.

  **Пример 1** Использование bind для создания функции с фиксированным контекстом

```js
const person = {
  name: "Jack",
  sayHi(phrase) {
    console.log(`${phrase}, ${this.name}`);
  },
};

const admin = { name: "Админ" };

const adminSayHi = person.sayHi.bind(admin);
adminSayHi("Привет"); // Привет, Админ
```

**Пример 2** Фиксация аргументов с помощью bind

```js
function multiply(a, b) {
  return a * b;
}

const double = multiply.bind(null, 2); // Фиксируем первый аргумент (a = 2)
console.log(double(5)); // 10 (2 * 5)
```

## call()

- `call` вызывает функцию с указанным контекстом (`this`) и аргументами, переданными через запятую.

### Синтаксис

```js

func.call(context, arg1, arg2, ...);

```

## apply()

- `apply`вызывает функцию с указанным контекстом (`this`) и принимает аргументы в виде массива.

### Синтаксис

```js

func.apply(context, [arg1, arg2, ...]);

```

# Задачи декораторы

### **Задача 1**

Декоратор для измерения времени выполнения. Создайте декоратор `timingDecorator`, который измеряет время выполнения функции и выводит его в консоль.

Логируйте время выполнения в формате: "Функция выполнена за ... мс".

Пример использования:

```javascript
function slow(x) {
  // Ресурсоёмкая задача
  for (let i = 0; i < 5e8; i++) {}

  return x * 2;
}

function timingDecorator(slow) {
  return function (x) {
    const startTime = Date.now();

    const result = slow(x);

    const endTime = Date.now();

    console.log(`Функция выполнена за ${endTime - startTime} мс`);
    return result;
  };
}

slow = timingDecorator(slow);

console.log(slow(5)); // Лог: "Функция выполнена за 500 мс"
```

### **Задача 2**

Ограничение частоты вызовов (throttling) Создайте декоратор `throttle`, который ограничивает частоту вызова функции. Функция `onScroll` должна срабатывать не чаще, чем раз в 2 секунды. Если вызов происходит чаще, он игнорируется.

```js
function onScroll() {
  console.log("Прокрутка страницы");
}

function throttle(onScroll, delay) {
  let lastCallTime = 0;
  return function () {
    const currentTime = Date.now();
    if (currentTime - lastCallTime >= delay) {
      console.log(Math.floor((currentTime - lastCallTime) / 1000));
      lastCallTime = currentTime;
      onScroll(lastCallTime, currentTime);
    }
    if (!lastCallTime) {
      return onScroll();
    }
  };
}

const throttledScroll = throttle(onScroll, 2000);

window.addEventListener("scroll", throttledScroll);
```

### **Задача 3**

Ограничение вызовов (once). Создайте декоратор `onceDecorator`, который гарантирует, что функция может быть вызвана только один раз.

```js
function init() {
  console.log("Инициализация выполнена");
}

function onceDecorator() {
  let call = false;
  return function () {
    if (call) {
      return;
    } else {
      init();
      call = true;
    }
  };
}

const initOnce = onceDecorator(init);
initOnce();
initOnce();
initOnce();
// initOnce() - "Инициализация выполнена" ;
//  Больше ничего не выводит, так как вызов возможен только один раз
```
