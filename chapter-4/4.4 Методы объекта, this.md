## Методы объекта, "this"

1. Что такое this?.

-   для доступа к информации внутри объекта метод может использовать ключевое слово this

2. Как "потерять" this?

3. Как "не терять" this?

4. Чему равен this в свойствах объекта?

5. Чему равен this в геттерах/сеттерах объекта?

6. Чему равен this внутри функции-стрелки?

7. Как сделать, чтобы объект:

-   был равен определенному числу?

-   был равен определенной строке?

-   obj > 0 // true. Как это сделать?

8. Как это сделать? String(obj < 0) + String(obj < 0) // "truefalse".

```js
let user = {
    name: "John",
    age: 30,
};

user.sayHi = function () {
    console.log("Привет!");
};

user.sayHi(); // Привет!
```

Когда мы пишем наш код, используя объекты для представления сущностей реального мира, – это называется объектно-ориентированным программированием или сокращённо: «ООП»

-   длинный синтаксис для методов, исп ключевое слово `function`:

```js
user = {
    sayHi: function () {
        console.log("Привет");
    },
};
```

-   короткий синтаксис для методов:

```js
// сокращённая запись
user = {
    sayHi() {
        // то же самое, что и "sayHi: function(){...}"
        console.log("Привет");
    },
};
```

## `this`

-   предоставляет доступ к информации объекта

```js
let user = {
    name: "John",
    age: 30,
    sayHi() {
        // "this" - это "текущий объект".
        console.log("1", this.name);
        console.log("2", user.name);
    },
};
user.sayHi(); // John
```

-   если объект поменяет ссылку,

```js
let admin = user;
user = null; // перезапишем переменную для наглядности, теперь она не хранит ссылку на объект.

admin.sayHi(); //  this.name = "John", user.name = Cannot read properties of null (reading 'name')
```

-   «this» не является фиксированным

```js
let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
    console.log(this.name);
}

function getObj() {
    return this;
}

// используем одну и ту же функцию в двух объектах
user.f = sayHi;
admin.f = sayHi;

user.getObj = getObj;
admin.getObj = getObj;

// эти вызовы имеют  разное значение this
// "this" внутри функции - это объект "перед точкой"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

console.log("this", user === user.getObj()); // true
console.log("this", admin === admin.getObj()); // true

admin["f"](); // Admin (нет разницы между использованием точки или квадратных скобок для доступа к объекту)
```

-   вызов без объекта:

1. в "use strict" this равен undefined
2. в нестрогом режиме значением this будет глобальный объект window

```js
function sayHi() {
    console.log(this);
}

sayHi(); // undefined
```

`this является «свободным», его значение вычисляется в момент вызова метода и не зависит от того, где этот метод был объявлен, а скорее от того, какой объект вызывает метод (какой объект стоит «перед точкой»).`

-   у стрелочных функций нет «this»

```js
let user = {
    firstName: "Ilya",
    sayHi() {
        let arrow = () => console.log(this.firstName);
        arrow();
    },
    arrow: (() => console.log("arrow this:", this.firstName))(),
};

user.sayHi(); // arrow this: undefined, Ilya
```

## Практика

1. Создайте объект calculator (калькулятор) с тремя методами:

-   `read()` (читать) запрашивает два значения и сохраняет их как свойства объекта с именами a и b.
-   `sum()` (суммировать) возвращает сумму сохранённых значений.
-   `mul()` (умножить) перемножает сохранённые значения и возвращает результат.

```js
let calculator = {
    result: 0,
    num1: 1,
    num2: 2,
    read() {
        return this.result;
    },
    sum() {
        this.result = this.num1 + this.num2;
    },
    mul() {
        this.result = this.num1 * this.num2;
    },
};
calculator.mul();
calculator.sum();
console.log("calculator.read:", calculator.read());
```

2. У нас есть объект ladder (лестница), который позволяет подниматься и спускаться:

// ladder.up().up().down().showStep().down().showStep(); // показывает 1 затем 0

```js
let ladder = {
    step: 0,
    up() {
        this.step++;
    },
    down() {
        this.step--;
    },
    showStep: function () {
        // показывает текущую ступеньку
        console.log(this.step);
    },
};

// решение

let ladder = {
    step: 0,
    up() {
        this.step++;
        return this;
    },
    down() {
        this.step--;
        return this;
    },
    showStep: function () {
        // показывает текущую ступеньку
        console.log(this.step);
        return this;
    },
};

ladder.up().up().down().showStep().down().showStep(); //  ladder.up().up().down().showStep().down().showStep(); // показывает 1 затем 0
```
